name: Create Release

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type de release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: 'Version personnalis√©e (optionnel)'
        required: false
        type: string

jobs:
  analyze-commits:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check-commits.outputs.should_release }}
      release_type: ${{ steps.check-commits.outputs.release_type }}
      new_version: ${{ steps.bump-version.outputs.new_version }}
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Check for conventional commits
      id: check-commits
      run: |
        # Obtenir la derni√®re version tagg√©e ou HEAD^ si pas de tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo HEAD^)
        
        # R√©cup√©rer tous les commits depuis la derni√®re version
        ALL_COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s")
        
        # V√©rifier s'il y a des commits conventionnels
        FEATURES=$(echo "$ALL_COMMITS" | grep -E "^feat:" || echo "")
        FIXES=$(echo "$ALL_COMMITS" | grep -E "^fix:" || echo "")
        BREAKING=$(echo "$ALL_COMMITS" | grep -E "BREAKING CHANGE" || echo "")
        
        # D√©terminer le type de release
        if [ -n "$BREAKING" ]; then
          RELEASE_TYPE="major"
        elif [ -n "$FEATURES" ]; then
          RELEASE_TYPE="minor"
        elif [ -n "$FIXES" ]; then
          RELEASE_TYPE="patch"
        else
          RELEASE_TYPE="none"
        fi
        
        # D√©terminer si on doit cr√©er une release
        if [ "$RELEASE_TYPE" != "none" ] || [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          SHOULD_RELEASE="true"
        else
          SHOULD_RELEASE="false"
        fi
        
        echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
        
        echo "Commits analys√©s depuis $LAST_TAG:"
        echo "Features: $(echo "$FEATURES" | wc -l)"
        echo "Fixes: $(echo "$FIXES" | wc -l)"
        echo "Breaking changes: $(echo "$BREAKING" | wc -l)"
        echo "Release type: $RELEASE_TYPE"
        echo "Should release: $SHOULD_RELEASE"

    - name: Bump version
      id: bump-version
      if: steps.check-commits.outputs.should_release == 'true'
      run: |
        CURRENT_VERSION=$(node -p "require('./package.json').version")
        
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          if [ -n "${{ github.event.inputs.custom_version }}" ]; then
            NEW_VERSION="${{ github.event.inputs.custom_version }}"
          else
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            NEW_VERSION=$(node -e "
              const semver = require('semver');
              const current = '$CURRENT_VERSION';
              const type = '$RELEASE_TYPE';
              console.log(semver.inc(current, type));
            ")
          fi
        else
          RELEASE_TYPE="${{ steps.check-commits.outputs.release_type }}"
          NEW_VERSION=$(node -e "
            const semver = require('semver');
            const current = '$CURRENT_VERSION';
            const type = '$RELEASE_TYPE';
            console.log(semver.inc(current, type));
          ")
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "Bumping version from $CURRENT_VERSION to $NEW_VERSION"

  create-release:
    needs: analyze-commits
    if: needs.analyze-commits.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Update package.json version
      run: |
        NEW_VERSION="${{ needs.analyze-commits.outputs.new_version }}"
        npm version $NEW_VERSION --no-git-tag-version
        echo "Version updated to $NEW_VERSION"

    - name: Get commit messages by type
      id: get-commits
      run: |
        # Obtenir la derni√®re version tagg√©e ou HEAD^ si pas de tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo HEAD^)
        
        # R√©cup√©rer tous les commits depuis la derni√®re version
        ALL_COMMITS=$(git log $LAST_TAG..HEAD --pretty=format:"%s")
        
        # Cat√©goriser les commits par type
        FEATURES=$(echo "$ALL_COMMITS" | grep -E "^feat:" || echo "")
        FIXES=$(echo "$ALL_COMMITS" | grep -E "^fix:" || echo "")
        DOCS=$(echo "$ALL_COMMITS" | grep -E "^docs:" || echo "")
        CHORES=$(echo "$ALL_COMMITS" | grep -E "^chore:" || echo "")
        REFACTORS=$(echo "$ALL_COMMITS" | grep -E "^refactor:" || echo "")
        TESTS=$(echo "$ALL_COMMITS" | grep -E "^test:" || echo "")
        STYLES=$(echo "$ALL_COMMITS" | grep -E "^style:" || echo "")
        PERFS=$(echo "$ALL_COMMITS" | grep -E "^perf:" || echo "")
        
        # Formater les commits pour le changelog
        format_commits() {
          echo "$1" | while IFS= read -r commit; do
            if [ -n "$commit" ]; then
              # Extraire le message sans le pr√©fixe
              message=$(echo "$commit" | sed 's/^[^:]*: //')
              echo "- $message"
            fi
          done
        }
        
        # Stocker les commits format√©s
        echo "features<<EOF" >> $GITHUB_OUTPUT
        format_commits "$FEATURES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "fixes<<EOF" >> $GITHUB_OUTPUT
        format_commits "$FIXES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "docs<<EOF" >> $GITHUB_OUTPUT
        format_commits "$DOCS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "chores<<EOF" >> $GITHUB_OUTPUT
        format_commits "$CHORES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "refactors<<EOF" >> $GITHUB_OUTPUT
        format_commits "$REFACTORS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "tests<<EOF" >> $GITHUB_OUTPUT
        format_commits "$TESTS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "styles<<EOF" >> $GITHUB_OUTPUT
        format_commits "$STYLES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        echo "perfs<<EOF" >> $GITHUB_OUTPUT
        format_commits "$PERFS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Update CHANGELOG.md
      id: update-changelog
      run: |
        VERSION="${{ needs.analyze-commits.outputs.new_version }}"
        CURRENT_DATE=$(date +%Y-%m-%d)
        
        # Cr√©er une entr√©e pour la nouvelle version
        cat > temp_changelog.md << EOF
        ## [$VERSION] - $CURRENT_DATE
        
        EOF
        
        # Ajouter les fonctionnalit√©s si elles existent
        if [ -n "${{ steps.get-commits.outputs.features }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üöÄ Ajout√©
        ${{ steps.get-commits.outputs.features }}
        
        EOF
        fi
        
        # Ajouter les corrections si elles existent
        if [ -n "${{ steps.get-commits.outputs.fixes }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üêõ Corrig√©
        ${{ steps.get-commits.outputs.fixes }}
        
        EOF
        fi
        
        # Ajouter la documentation si elle existe
        if [ -n "${{ steps.get-commits.outputs.docs }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üìö Documentation
        ${{ steps.get-commits.outputs.docs }}
        
        EOF
        fi
        
        # Ajouter les refactorisations si elles existent
        if [ -n "${{ steps.get-commits.outputs.refactors }}" ]; then
          cat >> temp_changelog.md << EOF
        ### ‚ôªÔ∏è Refactorisation
        ${{ steps.get-commits.outputs.refactors }}
        
        EOF
        fi
        
        # Ajouter les tests si ils existent
        if [ -n "${{ steps.get-commits.outputs.tests }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üß™ Tests
        ${{ steps.get-commits.outputs.tests }}
        
        EOF
        fi
        
        # Ajouter les styles si ils existent
        if [ -n "${{ steps.get-commits.outputs.styles }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üíÑ Style
        ${{ steps.get-commits.outputs.styles }}
        
        EOF
        fi
        
        # Ajouter les performances si elles existent
        if [ -n "${{ steps.get-commits.outputs.perfs }}" ]; then
          cat >> temp_changelog.md << EOF
        ### ‚ö° Performance
        ${{ steps.get-commits.outputs.perfs }}
        
        EOF
        fi
        
        # Ajouter les t√¢ches de maintenance si elles existent
        if [ -n "${{ steps.get-commits.outputs.chores }}" ]; then
          cat >> temp_changelog.md << EOF
        ### üîß Maintenance
        ${{ steps.get-commits.outputs.chores }}
        
        EOF
        fi
        
        # Ajouter la ligne de s√©paration
        cat >> temp_changelog.md << EOF
        ---
        
        EOF
        
        # Ajouter au d√©but du CHANGELOG.md (apr√®s la section Unreleased)
        if grep -q "## \[Unreleased\]" CHANGELOG.md; then
          # Ins√©rer apr√®s la ligne Unreleased
          sed -i "/^## \[Unreleased\]/r temp_changelog.md" CHANGELOG.md
        else
          # Si pas de section Unreleased, ajouter au d√©but
          cat temp_changelog.md CHANGELOG.md > temp_combined.md
          mv temp_combined.md CHANGELOG.md
        fi
        rm temp_changelog.md
        
        echo "CHANGELOG mis √† jour pour la version $VERSION avec cat√©gorisation des commits"

    - name: Commit and push changes
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add package.json CHANGELOG.md
        git commit -m "chore: bump version to ${{ needs.analyze-commits.outputs.new_version }} and update CHANGELOG"
        git push origin main

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ needs.analyze-commits.outputs.new_version }}
        name: Release v${{ needs.analyze-commits.outputs.new_version }}
        body: |
          ## What's Changed
          
          ${{ steps.get-commits.outputs.features != '' && '### üöÄ Nouvelles Fonctionnalit√©s' || '' }}
          ${{ steps.get-commits.outputs.features }}
          
          ${{ steps.get-commits.outputs.fixes != '' && '### üêõ Corrections' || '' }}
          ${{ steps.get-commits.outputs.fixes }}
          
          ${{ steps.get-commits.outputs.docs != '' && '### üìö Documentation' || '' }}
          ${{ steps.get-commits.outputs.docs }}
          
          ${{ steps.get-commits.outputs.refactors != '' && '### ‚ôªÔ∏è Refactorisations' || '' }}
          ${{ steps.get-commits.outputs.refactors }}
          
          ${{ steps.get-commits.outputs.tests != '' && '### üß™ Tests' || '' }}
          ${{ steps.get-commits.outputs.tests }}
          
          ${{ steps.get-commits.outputs.perfs != '' && '### ‚ö° Performances' || '' }}
          ${{ steps.get-commits.outputs.perfs }}
          
          ${{ steps.get-commits.outputs.chores != '' && '### üîß Maintenance' || '' }}
          ${{ steps.get-commits.outputs.chores }}
          
          ## Docker Images
          - Latest: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-api:latest`
          - Version: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-api:${{ needs.analyze-commits.outputs.new_version }}`
          - Commit: `${{ secrets.DOCKERHUB_USERNAME }}/benevoclic-api:${{ github.sha }}`
          
          ## üìã CHANGELOG
          
          Consultez le [CHANGELOG.md](CHANGELOG.md) pour plus de d√©tails.
          
          ## üöÄ D√©clenchement
          
          ${{ github.event_name == 'workflow_dispatch' && 'Release d√©clench√©e manuellement' || 'Release d√©clench√©e automatiquement bas√©e sur les commits conventionnels' }}
        draft: false
        prerelease: false
        token: ${{ secrets.GITHUB_TOKEN }}

  # Job pour d√©ployer automatiquement (optionnel - seulement pour workflow manuel)
  deploy-release:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    needs: create-release
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "D√©ploiement de la version $VERSION"

      - name: Deploy to Production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.OVH_SSH_KEY }}
          port: 22
          script: |
            set -e
            echo "üöÄ D√©ploiement de la version ${{ steps.version.outputs.version }}"
            
            # Aller dans le r√©pertoire
            cd ~/benevoclic || exit 1
            echo "üìÅ R√©pertoire: $(pwd)"
            
            # V√©rifier Git
            git status || echo "‚ö†Ô∏è Probl√®me avec Git"
            
            # Mettre √† jour le code
            echo "üì• Mise √† jour du code..."
            git pull origin main || exit 1
            
            # Installer les d√©pendances
            echo "üì¶ Installation des d√©pendances..."
            npm install || exit 1
            
            # Build de l'application
            echo "üî® Build de l'application..."
            npm run build || exit 1
            
            # Red√©marrer les services
            echo "üîÑ Red√©marrage des services..."
            pm2 restart benevoclic-api || exit 1
            
            # V√©rifier le d√©ploiement
            echo "üîç V√©rification du d√©ploiement..."
            sleep 10
            curl -f http://${{ secrets.VPS_HOST }}:3000/health || exit 1
            
            echo "‚úÖ D√©ploiement de la version ${{ steps.version.outputs.version }} termin√© !"

      - name: Notify Discord
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            curl -X POST -H "Content-Type: application/json" \
              -d "{\"content\":\"‚úÖ **Release v${{ steps.version.outputs.version }} d√©ploy√©e avec succ√®s !**\\n\\nüì¶ Version: v${{ steps.version.outputs.version }}\\nüîó [Voir les changements](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }})\\nüìä [Monitoring](http://${{ secrets.VPS_HOST }}:9090)\"}" \
              ${{ secrets.WEBHOOK_URL }}
          else
            curl -X POST -H "Content-Type: application/json" \
              -d "{\"content\":\"‚ùå **√âchec du d√©ploiement de la release v${{ steps.version.outputs.version }}**\\n\\nüîç V√©rifiez les logs du workflow pour plus de d√©tails.\"}" \
              ${{ secrets.WEBHOOK_URL }}
          fi