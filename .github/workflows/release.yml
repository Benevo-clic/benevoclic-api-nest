name: Release Management

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type de release (manuel)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      deploy_to_ovh:
        description: 'D√©ployer sur OVH'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  actions: read
  id-token: write

jobs:
  # Job pour analyser les commits et cr√©er une release automatiquement
  analyze-commits:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.analyze.outputs.should_release }}
      release_type: ${{ steps.analyze.outputs.release_type }}
      new_version: ${{ steps.analyze.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Analyze commits for release
        id: analyze
        run: |
          # Lire la version actuelle
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          
          # Analyser les commits depuis la derni√®re release
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "LAST_TAG=$LAST_TAG" >> $GITHUB_ENV
          
          # Obtenir les commits depuis la derni√®re release
          COMMITS=$(git log --oneline --no-merges ${LAST_TAG}..HEAD)
          echo "COMMITS=$COMMITS" >> $GITHUB_ENV
          
          # Analyser les types de commits
          MAJOR_COMMITS=$(echo "$COMMITS" | grep -E "^(feat|fix|docs|style|refactor|perf|test|chore)\(.*\)!:" | wc -l)
          MINOR_COMMITS=$(echo "$COMMITS" | grep -E "^(feat)\(.*\):" | wc -l)
          PATCH_COMMITS=$(echo "$COMMITS" | grep -E "^(fix|docs|style|refactor|perf|test|chore)\(.*\):" | wc -l)
          
          echo "MAJOR_COMMITS=$MAJOR_COMMITS" >> $GITHUB_ENV
          echo "MINOR_COMMITS=$MINOR_COMMITS" >> $GITHUB_ENV
          echo "PATCH_COMMITS=$PATCH_COMMITS" >> $GITHUB_ENV
          
          # D√©terminer si une release est n√©cessaire
          if [ $MAJOR_COMMITS -gt 0 ]; then
            RELEASE_TYPE="major"
            SHOULD_RELEASE="true"
          elif [ $MINOR_COMMITS -gt 0 ]; then
            RELEASE_TYPE="minor"
            SHOULD_RELEASE="true"
          elif [ $PATCH_COMMITS -gt 0 ]; then
            RELEASE_TYPE="patch"
            SHOULD_RELEASE="true"
          else
            RELEASE_TYPE="none"
            SHOULD_RELEASE="false"
          fi
          
          echo "RELEASE_TYPE=$RELEASE_TYPE" >> $GITHUB_ENV
          echo "SHOULD_RELEASE=$SHOULD_RELEASE" >> $GITHUB_ENV
          
          # Calculer la nouvelle version si n√©cessaire
          if [ "$SHOULD_RELEASE" = "true" ]; then
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR=${VERSION_PARTS[0]}
            MINOR=${VERSION_PARTS[1]}
            PATCH=${VERSION_PARTS[2]}
            
            if [ "$RELEASE_TYPE" = "major" ]; then
              NEW_MAJOR=$((MAJOR + 1))
              NEW_VERSION="$NEW_MAJOR.0.0"
            elif [ "$RELEASE_TYPE" = "minor" ]; then
              NEW_MINOR=$((MINOR + 1))
              NEW_VERSION="$MAJOR.$NEW_MINOR.0"
            else
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
            fi
            
            echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
            echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          else
            echo "new_version=" >> $GITHUB_OUTPUT
          fi
          
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          
          echo "Analyse termin√©e:"
          echo "- Commits majeurs: $MAJOR_COMMITS"
          echo "- Commits mineurs: $MINOR_COMMITS"
          echo "- Commits patch: $PATCH_COMMITS"
          echo "- Type de release: $RELEASE_TYPE"
          echo "- Release n√©cessaire: $SHOULD_RELEASE"
          if [ "$SHOULD_RELEASE" = "true" ]; then
            echo "- Nouvelle version: $NEW_VERSION"
          fi

  # Job pour cr√©er une release automatiquement
  create-auto-release:
    if: needs.analyze-commits.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    needs: analyze-commits
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Bump version
        id: bump
        run: |
          # Utiliser la version calcul√©e par analyze-commits
          NEW_VERSION="${{ needs.analyze-commits.outputs.new_version }}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version calcul√©e: $NEW_VERSION"

      - name: Update package.json version
        run: |
          npm version ${{ steps.bump.outputs.new_version }} --no-git-tag-version
          echo "Version mise √† jour vers ${{ steps.bump.outputs.new_version }}"

      - name: Generate CHANGELOG entry
        run: |
          # Cr√©er une entr√©e temporaire pour la nouvelle version
          NEW_VERSION="${{ steps.bump.outputs.new_version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)
          
          # Cr√©er un fichier temporaire avec la nouvelle entr√©e
          cat > temp_changelog.md << EOF
          ## [$NEW_VERSION] - $CURRENT_DATE
          
          ### üöÄ Ajout√©
          - Release $NEW_VERSION
          
          ### üîß Modifi√©
          - Mise √† jour de la version
          
          ---
          
          EOF
          
          # Ajouter au d√©but du CHANGELOG.md (apr√®s la section Unreleased)
          if grep -q "## \[Unreleased\]" CHANGELOG.md; then
            sed -i "/^## \[Unreleased\]/a\\" temp_changelog.md
            sed -i "/^## \[Unreleased\]/r temp_changelog.md" CHANGELOG.md
          else
            # Si pas de section Unreleased, ajouter √† la fin
            echo "" >> CHANGELOG.md
            cat temp_changelog.md >> CHANGELOG.md
          fi
          rm temp_changelog.md

      - name: Commit and push changes
        run: |
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to ${{ steps.bump.outputs.new_version }}"
          git push origin main

      - name: Create Git tag
        run: |
          git tag -a "v${{ steps.bump.outputs.new_version }}" -m "Release v${{ steps.bump.outputs.new_version }}"
          git push origin "v${{ steps.bump.outputs.new_version }}"

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.bump.outputs.new_version }}
          release_name: Release v${{ steps.bump.outputs.new_version }}
          body: |
            ## üöÄ Release v${{ steps.bump.outputs.new_version }}
            
            ### üìã R√©sum√© des changements
            
            Consultez le [CHANGELOG.md](CHANGELOG.md) pour plus de d√©tails.
            
            ### üîÑ D√©ploiement
            
            Cette release peut √™tre d√©ploy√©e manuellement si n√©cessaire.
            
            ### üìä Monitoring
            
            - [Prometheus](http://IP_VPS:9090)
            - [Grafana](http://IP_VPS:3001)
            - [Alertmanager](http://IP_VPS:9093)
            
            ---
            
            *Release g√©n√©r√©e automatiquement*
          draft: false
          prerelease: false

  # Job pour cr√©er une release manuellement
  create-manual-release:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Configure Git
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

      - name: Bump version
        id: bump
        run: |
          # Lire la version actuelle
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_ENV
          
          # Configuration pour le bump de version
          if [ "${{ github.event.inputs.release_type }}" = "major" ]; then
            echo "RELEASE_TYPE=major" >> $GITHUB_ENV
          elif [ "${{ github.event.inputs.release_type }}" = "minor" ]; then
            echo "RELEASE_TYPE=minor" >> $GITHUB_ENV
          else
            echo "RELEASE_TYPE=patch" >> $GITHUB_ENV
          fi
          
          # Calculer la nouvelle version
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          if [ "$RELEASE_TYPE" = "major" ]; then
            NEW_MAJOR=$((MAJOR + 1))
            NEW_VERSION="$NEW_MAJOR.0.0"
          elif [ "$RELEASE_TYPE" = "minor" ]; then
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="$MAJOR.$NEW_MINOR.0"
          else
            NEW_PATCH=$((PATCH + 1))
            NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          fi
          
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Version calcul√©e: $NEW_VERSION"

      - name: Update package.json version
        run: |
          npm version ${{ steps.bump.outputs.new_version }} --no-git-tag-version
          echo "Version mise √† jour vers ${{ steps.bump.outputs.new_version }}"

      - name: Generate CHANGELOG entry
        run: |
          # Cr√©er une entr√©e temporaire pour la nouvelle version
          NEW_VERSION="${{ steps.bump.outputs.new_version }}"
          CURRENT_DATE=$(date +%Y-%m-%d)
          
          # Cr√©er un fichier temporaire avec la nouvelle entr√©e
          cat > temp_changelog.md << EOF
          ## [$NEW_VERSION] - $CURRENT_DATE
          
          ### üöÄ Ajout√©
          - Release $NEW_VERSION
          
          ### üîß Modifi√©
          - Mise √† jour de la version
          
          ---
          
          EOF
          
          # Ajouter au d√©but du CHANGELOG.md (apr√®s la section Unreleased)
          if grep -q "## \[Unreleased\]" CHANGELOG.md; then
            sed -i "/^## \[Unreleased\]/a\\" temp_changelog.md
            sed -i "/^## \[Unreleased\]/r temp_changelog.md" CHANGELOG.md
          else
            # Si pas de section Unreleased, ajouter √† la fin
            echo "" >> CHANGELOG.md
            cat temp_changelog.md >> CHANGELOG.md
          fi
          rm temp_changelog.md

      - name: Commit and push changes
        run: |
          git add package.json CHANGELOG.md
          git commit -m "chore: bump version to ${{ steps.bump.outputs.new_version }}"
          git push origin main

      - name: Create Git tag
        run: |
          git tag -a "v${{ steps.bump.outputs.new_version }}" -m "Release v${{ steps.bump.outputs.new_version }}"
          git push origin "v${{ steps.bump.outputs.new_version }}"

      - name: Create Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.bump.outputs.new_version }}
          release_name: Release v${{ steps.bump.outputs.new_version }}
          body: |
            ## üöÄ Release v${{ steps.bump.outputs.new_version }}
            
            ### üìã R√©sum√© des changements
            
            Consultez le [CHANGELOG.md](CHANGELOG.md) pour plus de d√©tails.
            
            ### üîÑ D√©ploiement
            
            Cette release peut √™tre d√©ploy√©e manuellement si n√©cessaire.
            
            ### üìä Monitoring
            
            - [Prometheus](http://IP_VPS:9090)
            - [Grafana](http://IP_VPS:3001)
            - [Alertmanager](http://IP_VPS:9093)
            
            ---
            
            *Release g√©n√©r√©e automatiquement*
          draft: false
          prerelease: false

  # Job pour d√©ployer automatiquement (optionnel)
  deploy-release:
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || 
         (github.event_name == 'workflow_dispatch' && github.event.inputs.deploy_to_ovh == 'true')
    runs-on: ubuntu-latest
    needs: [create-auto-release, create-manual-release]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ needs.create-manual-release.outputs.new_version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "D√©ploiement de la version $VERSION"

      - name: Deploy to Production
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.OVH_SSH_KEY }}
          port: 22
          script: |
            set -e
            echo "üöÄ D√©ploiement de la version ${{ steps.version.outputs.version }}"
            
            # V√©rifier si le r√©pertoire existe
            if [ ! -d ~/benevoclic ]; then
              echo "üìÅ R√©pertoire benevoclic n'existe pas, cr√©ation..."
              mkdir -p ~/benevoclic
              cd ~/benevoclic
              echo "üì• Clonage du repository..."
              git clone https://github.com/Benevo-clic/benevoclic-api-nest.git .
            else
              echo "üìÅ R√©pertoire benevoclic existe"
              cd ~/benevoclic
              
              # V√©rifier si c'est un repository Git
              if [ ! -d .git ]; then
                echo "üì• R√©pertoire n'est pas un repository Git, clonage..."
                rm -rf *
                git clone https://github.com/Benevo-clic/benevoclic-api-nest.git .
              else
                echo "‚úÖ Repository Git trouv√©"
              fi
            fi
            
            # Mettre √† jour le code
            echo "üì• Mise √† jour du code..."
            git pull origin main
            
            # Installer les d√©pendances
            echo "üì¶ Installation des d√©pendances..."
            npm install
            
            # Build de l'application
            echo "üî® Build de l'application..."
            npm run build
            
            # Red√©marrer les services
            echo "üîÑ Red√©marrage des services..."
            pm2 restart benevoclic-api || pm2 start ecosystem.config.js
            
            # V√©rifier le d√©ploiement
            echo "üîç V√©rification du d√©ploiement..."
            sleep 10
            curl -f http://${{secrets.IP}}:3000/health || exit 1
            
            echo "‚úÖ D√©ploiement de la version ${{ steps.version.outputs.version }} termin√© !"

      - name: Notify Discord
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            curl -X POST -H "Content-Type: application/json" \
              -d "{\"content\":\"‚úÖ **Release v${{ steps.version.outputs.version }} d√©ploy√©e avec succ√®s !**\\n\\nüì¶ Version: v${{ steps.version.outputs.version }}\\nüîó [Voir les changements](https://github.com/${{ github.repository }}/releases/tag/v${{ steps.version.outputs.version }})\\nüìä [Monitoring](http://${{secrets.IP}}:9090)\"}" \
              ${{ secrets.WEBHOOK_URL }}
          else
            curl -X POST -H "Content-Type: application/json" \
              -d "{\"content\":\"‚ùå **√âchec du d√©ploiement de la release v${{ steps.version.outputs.version }}**\\n\\nüîç V√©rifiez les logs du workflow pour plus de d√©tails.\"}" \
              ${{ secrets.WEBHOOK_URL }}
          fi

  # Job pour g√©n√©rer les release notes
  generate-release-notes:
    if: (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) || 
         (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    needs: [create-auto-release, create-manual-release]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        id: release_notes
        run: |
          # Extraire la version
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ needs.create-manual-release.outputs.new_version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
          fi
          
          # G√©n√©rer les release notes depuis le CHANGELOG.md
          if [ -f "CHANGELOG.md" ]; then
            RELEASE_NOTES=$(awk "/^## \\[$VERSION\\]/ {p=1; next} /^## \\[/ {p=0} p" CHANGELOG.md | sed '/^$/d')
            echo "release_notes<<EOF" >> $GITHUB_OUTPUT
            echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "release_notes<<EOF" >> $GITHUB_OUTPUT
            echo "Release $VERSION" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Update Release
        uses: actions/github-script@v7
        with:
          script: |
            let version;
            if ('${{ github.event_name }}' === 'workflow_dispatch') {
              version = '${{ needs.create-manual-release.outputs.new_version }}';
            } else {
              version = context.ref.replace('refs/tags/v', '');
            }
            
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            const release = releases.find(r => r.tag_name === `v${version}`);
            
            if (release) {
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                body: `${{ steps.release_notes.outputs.release_notes }}`
              });
            } 